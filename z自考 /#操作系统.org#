* 第一章 引论
** 什么是操作系统
*** 计算机系统
    - 简称 :: OS
    - 定义 :: 按用户要求接受和存储信息，自动进行数据处理并输出结果信息的系统
    - 构成 :: 硬件系统和软件系统
    - 软件系统组成 :: 系统软件 支撑软件 应用软件
    - 硬件系统组成 :: 中央处理器（CPU）、主存储器、辅助存储器、各种
*** 操作系统
    - 定义 :: 管理计算机资源 控制程序的执行 改善人机界面 为其他软件提供支持
    - 设计原则
      + 方便
      + 高效
    - 特点
      + 并发性 :: 同时存在多个程序运行，从宏观上看，这些程序都在向前推进
      + 共享性 :: 多个用户共用系统中的各种资源
      + 随机性 :: 不能对所运行的程序行为以及硬件设备做出事先的假设
    - 研究操作系统的观点
      + 软件的观点 :: 多种功能程序的集合
        * 外在特性 :: 接口
        * 内在特性 :: 与硬件交互
      + 资源管理的观点 :: 负责登记谁使用资源 还有哪些空闲资源 响应对谁的资源请求 回收不再使用的资源
      + 进程的观点 :: 由多个可以同时独立运行的程序和一个对这些程序进行协调的核心
      + 虚机器的观点 :: 用户不需要使用硬件机器 通过操作系统提供的手段控制和使用计算机
      + 服务提供者的观点 :: 站在操作系统之外观察操作系统 提供功能更强 质量更高 更方便灵活的虚拟机
** 操作系统的功能
*** 进程管理
    - 实质 :: 对中央处理器进行管理
    - 功能
      + 进程的引入 :: 为了多道程序的并发而引入
      + 进程的简单定义 :: 一个程序的运行过程
      + 进程管理的内容 :: 进程控制 进程同步 进程间通信、调度
*** 内存管理
    - 任务 :: 管理计算机内存的资源
    - 功能
      + 内存的分配与回收 :: 为多个程序分配有限的内存空间， 运行完毕后需要回收
      + 存储保护 :: 多个程序和数据应该彼此隔离 互不侵扰
      + 内存扩充 :: 将辅助存储器作为内存的扩充空间
*** 文件管理
    - 任务 :: 支持文件的增删改查 解决文件的共享 保密 保护问题 方便用户 安全的访问文件
    - 功能
      + 文件存储空间的管理
      + 目录管理  
      + 文件系统的安全性 
*** 设备管理
    - 任务 :: 除了处理器和内存以外的所有输入输出设备的管理
    - 功能
      + 负责外部设备的分配  启动和故障处理
    - 采用的技术
      + 中断技术 通道技术 虚拟设备技术 缓冲技术
      + 尽可能发挥设备和主机的并行能力
*** 用户接口
    - 任务 :: 提供一个使用系统的良好环境 有效组织工作流程 使整个系统高效运行
** 操作系统的体系结构
*** windows 体系结构
    - 内核
    - 硬件抽象层HAL
    - 执行体
    - 系统进程和系统线程
*** unix 体系结构
    - 内核层
    - 系统层
    - 应用层
*** Linux 体系结构
    - 内核 shell 文件系统 应用程序
*** Android 体系结构
    - 从低到高 应用程序层 应用框架层 系统运行层 Linux内核层
*** 发展(了解)
** 操作系统的基本类型
*** 批处理
    - 定义 :: 将作业的说明，相应的程序，数据输入计算机，操作系统选择作业按作业要求自动执行作业的执行;
    - 目标 :: 系统资源利用率高 作业吞吐率高
    - 分类 :: 分为单道批处理和多道批处理
    - 优点 :: 提高系统的效率，没有交互性
    - 一般指令和特权指令
      + 操作系统的运行模式 :: 用户模式和特权模式
      + 处理器的状态 :: 目态和管态
      + 机器指令 :: 一般指令和特权指令
      + 系统调用 :: 用户不能使用特权指令 向操作系统请求 由操作系统调用完成
*** 分时
    - 定义 :: 支持多个终端用户，实现人机交互的系统
    - 优点 :: 具有多路(同时)性，独立性，及时性，交互性
*** 实时
    - 定义 :: 接到外部信号及时处理，在规定的时间处理结束，再给出反馈信号
    - 优点 :: 及时响应，快速处理，高可靠性和安全性
    - 分类 :: 硬实时操作系统和软实时操作系统
    - 功能
      + 实时时钟管理
      + 过载防护
      + 高可靠性
*** 网络
    - 定义 :: 计算机网络
    - 优点 :: 将网络中的计算机联合起来，实现各计算机的通信及资源共享 
*** 分布式 
    - 定义 :: 若干计算机相互协作完成一个共同的任务
    - 优点 :: 环形结构、星形结构和树形结构 
*** 嵌入式
    - 特点 :: 微型化和实时性
** 操作系统的设计
*** 设计过程
    - 功能设计
      + 跟目标有关
    - 算法设计
      + 算法和策略 分析和估算性能
    - 结构设计
*** 设计目标
    - 可靠性
    - 高效性
    - 易维护性
    - 可移植性
    - 安全性
    - 简明性
*** 结构设计
    - 系统模块化
    - 模块标准化
    - 通信规范化
*** 结构
    - 整体式结构
    - 层次式结构
    - 微内核结构
** 重点
*** 计算机系统
    - 分层结构 组成 资源分类
*** 操作系统的定义
*** 操作系统的分类
    - 批处理系统的基本工作方式 特点 工作原理 目标
    - 分时系统的基本工作方式 设计思想 特点
    - 实时系统的定义 设计目标
    - 嵌入式 网络 分布式 的定义和优点
*** 操作系统的设计
    - 设计过程
      + 功能设计 算法设计 结构设计
    - 设计目标
      + 可靠性 高效性 易维护性 可移植性 安全性 简明性
    - 结构
      - 整体式结构 层次式结构 微内核结构          
* 第二章 操作系统运行环境 
** 处理器
*** 处理器的构成与基本工作方式
    - 构成
      + 运算器 :: 实现算数与逻辑运算
      + 控制器 :: 控制程序运行流程
      + 寄存器 :: 执行指令过程 暂存数据 地址 指令信息
      + 高速缓存 :: 为CPU 内存 提供 高速缓存
    - 处理器中的寄存器
      + 两类寄存器
        * 用户可见寄存器 :: 由编译程序分配 减少程序访问内存次数
          - 一般包括 数据寄存器 地址寄存器 条件码寄存器
        * 控制和状态寄存器 :: 控制处理器操作
          - 常见的是 程序计数器(PC) 指令寄存器(IR) 程序状态字(PSW)
    - 指令执行的基本过程
      + 读取指令 将程序计数器值变为下一条指令地址
      + 放入指令寄存器 处理器解释执行
      + 指令的分类 :: 访问存储器指令 I/O指令 算数逻辑指令 控制转移指令 控制器控制指令
*** 特权指令和非特权指令
    - 特权指令
      + 只能由操作系统使用的命令
      + 不允许一般用户使用
      + 设置程序状态字 启动某设备等
    - 非特权指令
      + 普通用户使用的指令 
*** 处理器的工作状态
    - 目态和管态
      + 管态 :: 操作系统管理程序运行时的状态 又称内核态 系统态 较高权限
      + 目态 :: 一般用户程序执行时的状态 又称用户态 普通态 较低权限
    - 处理器工作状态的转换
      + 目 -> 管 :: 唯一途径 中断 PSW处理器状态标志位管态
      + 管 -> 目 :: 设置PSW指令
    - 限制用户使用特权指令 :: 用户程序执行取到特权指令 处理器拒绝该指令 形成"非法操作" 通知 程序中有非法操作
*** 程序状态字
    - 作用 :: 指示处理器状态的寄存器
    - 包括
      + CPU的工作状态代码 :: 管态  或者 目态
      + 条件码 :: 执行后的结果特征
      + 中断屏蔽码 :: 指出是否允许中断
** 计算机系统硬件部件
*** 存储系统
    - 存储器的类型
      + 类型 
        * 读写存储器(RAM) :: 存储随机存取的程序和数据
        * 只读存储器(ROM) :: 存放固化的程序
      + 存储分块
        * 最小单位 :: 位(bit)
        * 最小编制单位 :: 字节
        * 分块 :: 为了分配和管理方便 将内存划分大小相等的块 以块位单位分配内存空间
    - 存储器的层次结构
      + 容量 速度 成本的匹配
      + 存储访问局部性原理
      + 存储器保护 :: 保证每一个程序独立运行 互不干扰
      + 方法 :: 界地址寄存器
*** I/O部件 
    - I/O结构
    - 通道
    - DMA技术
    - 缓冲技术
*** 时钟部件
    - 功能
      + 发现死循环 防止浪费机时
      + 分时系统中 时钟间隔实现时间片转轮执行
      + 实时系统中 按要求时间 间隔控制设备
      + 定时唤醒各个外部事件
      + 记录 各设备使用时间 某外部时间发生时间
      + 记录绝对时间
    - 分类
      + 硬件时钟 软件时钟
      + 用途分 :: 绝对时钟 相对时钟
** 中断机制
*** 中断与异常的概念
    - 中断与异常
      + 中断 :: 处理器 对系统中或系统外 发生的异步事件的响应
        * 异步事件 :: 无一定时序关系的随机事件 
        * 中断源 :: 引起中断的事件
        * 中断请求 :: 中断源向处理器发出的请求信号
        * 中断处理程序 :: 处理中断事件的程序
        * 断点 :: 中断时执行程序的暂停点
        * 中断响应 :: 处理器暂停当前程序转而处理中断的过程
        * 中断返回 :: 中断处理程序结束后 恢复原来程序的执行
        * 中断向量表 :: 中断处理程序的入口地址映射表
      + 异常 :: 由正在执行的指令引发的中断
    - 中断与异常的分类
      + 典型中断 :: 时钟中断 输入输出中断 控制台中断 硬件故障中断
      + 典型异常 :: 程序性中断 访管指令异常  
*** 中断系统
    - 中断请求的接收 :: 一般由中断逻辑路线 中断寄存器实现
    - 中断响应 :: 处理器控制部件有中断信号扫描结构 在每条指令执行周期最后时刻扫描中断寄存器 若有中断 处理器接收硬件中断发来的中断向量代号 准备中断处理工作
        1) 处理器接收中断信号
        2) 保护现场
        3) 分析中断向量
        4) 将处理器的PC值重置为中断程序的入口地址
        5) 调用中断处理程序
    - 中断处理 :: 整个中断信号的接收 响应 处理过程 
        1) 接收和响应中断
        2) 保护中断断点现场
        3) 分析中断向量 调用中断处理程序
        4) 中断处理结束回复现场 原有程序继续执行
    - 几种典型中断的处理
      + I/O中断
      + 时钟中断
      + 硬件故障中断
      + 程序性中断
      + 系统服务请求
*** 中断优先级 中断屏蔽 中断嵌套
    - 多级中断与中断优先级
      + 作用
        * 根据紧急程度和重要性划分级别 有限处理紧急或重要的任务
        * 多个中断信号同时到达 如何选择首个被处理的中断信号的问题
      + 中断屏蔽 :: 允许或者禁止中断系统对 某些类别中断的响应
      + 中断嵌套 :: 多个中断源 在一个中断处理过程中又发生了中断，两种策略
        * 当处理一个中断禁止其他中断
        * 中断嵌套 :: 按照优先级划分 允许优先级高的中断优先级低的中断处理过程 优先进行处理
** 系统调用
*** 简介
    - 概念 :: 用户调用操作系统中的一些子功能 操作系统提供给编程人员的唯一接口
    - 系统调用与函数调用的区别
      + 运行在不同状态
      + 状态的转换
      + 返回问题
      + 嵌套调用
    - 系统调用的分类
      + 进程控制类
      + 文件操作类
      + 进程通信类
      + 设备管理类
      + 信息维护类
    - 系统调用库函数 API 内核函数 的关系
*** 处理过程
    - 陷入 :: 为控制系统调用服务的机构
    - 访管指令 :: 由于系统调用引起处理器中断的指令
** 重点
*** 处理器
    - 两类寄存器 用户可见寄存器 控制 状态
    - 特权指令和非特权指令的概念
    - 处理器的工作状态 管态 目态 以及二者的转换
    - 程序状态寄存器(PSW)
*** 计算机系统硬件部件
    - 存储系统的类型 ROM RAM
    - 存储的最小单位 二进制位 x最小编制单位 字节 内存分块
    - 存储保护硬件支持 界地址寄存器
    - I/O部件 通道 DMA 缓冲技术
*** 中断机制
    - 中断与异常的概念 分类
    - 中断系统 ： 中断请求 中断响应 中断处理 典型的中断的处理
    - 中断优先级 中断屏蔽 中断嵌套的概念
    - 系统调用 ： 概念 区别 过程  

* 第三章 进程与线程
** 多道程序设计
*** 程序的顺序执行
    - 顺序执行设计 
      + 程序 :: 在一个时间按严格次序前后相继的操作序列
      + 顺序执行 :: 具有独立功能的程序 独占处理器 直到得到结果的过程
    - 特点
      + 顺序性 :: 程序所规定的动作严格按顺序执行
      + 封闭性 :: 程序运行后 结果取决于给定的初始条件 不受外界因素影响
      + 确定性 :: 执行结果与之执行速度无关
      + 可再现性 :: 程序在不同的时间执行 初始条件相同 结果就会相同
*** 程序的并发执行
    - 两个或者以上程序同时处于开始执行尚未结束的状态
    - 并发程序 :: 参与并发执行的程序 
    - 特征
      + 执行期间并发程序相互制约
      + 程序计算不再一一对应  :: 允许多个程序共享一个程序段
      + 并发程序的执行结果不可在现 :: 与其执行的相对速度 并发程序之间的相互关系有关
      + 程序的并发执行和并行执行 :: 并发是宏观上的同时，实际还是顺序 并行是微观上的同时
*** 多道程序设计
    - 多道程序设计的引入 :: 大大的提高了系统的效率
    - 环境特点
      + 多道程序设计 :: 就是允许多个程序同时进入内存运行 提高整个系统的效率
      + 吞吐量 :: 单位时间内系统所处理进程的道数 用来衡量系统效率
      + 特点  
        * 独立性 :: 程序执行的起止时间独立的 执行速度与其他程序无关
        * 随机性 :: 程序和数据的输入与执行开始时间都是随机的
        * 资源共享性
    - 缺陷
      + 可能延长程序的执行时间
      + 系统效率的提高有一定的限度
** 进程 
*** 进程的定义
    - 定义 :: 具有一定独立功能的程序在某个数据集合的一次运行活动 系统进行资源分配和调度的一个独立单位
    - 分为 :: 系统进程 用户进程
    - 进程与程序的联系和区别
      + 联系
        * 程序是进程的组成之一 进程的目标是执行它对应的程序
        * 进程 = 程序 + 数据 + 进程控制块
      + 区别
        * 程序是静态的 进程是动态
        * 二者是多对多关系
    - 可再入程序
      + 可被多个用户调用的程序
      + 必须是纯代码 执行过程中不会修改自己代码 必须与数据隔离 
    - 进程的特征
      + 并发性
      + 动态性
      + 独立性
      + 交往性
      + 异步性
      + 结构性 
*** 进程的状态与转换
    - 三状态进程模型
      + 运行状态
      + 就绪状态
      + 等待状态
      + 状态转换
        * 就绪 -> 运行
        * 运行 -> 就绪
        * 运行 -> 等待
        * 等待 -> 就绪
    - 五状态进程模型
      + 运行状态
      + 就绪状态
      + 阻塞状态
      + 创建状态
      + 结束状态
    - 七状态进程模型
      + 执行状态
      + 就绪状态
      + 阻塞状态
      + 创建状态
      + 终止状态
      + 就绪/挂起状态
      + 阻塞/挂起状态
*** 进程控制块
    - 基本概念
      + 定义 :: 为了便于系统控制和描述进程的活动过程 在操作系统核心定义的数据结构 称为PCB
      + PCB是进程存在的唯一标志 因为系统创建一个进程要为进程设置一个PCB,利用PCB进行控制和管理 撤销进程会回收PCB 进程随之消
    - 内容
      + 调度信息 :: 供进程调度时使用 包括进程名 进程号 地址 空间信息 优先级 当前状态 资源清单等等
      + 现场信息 :: 刻画进程的运行情况 主要是CPU寄存器的信息 如程序状态字 时钟 
    - PCB组织
      + 线性方式
      + 索引方式
      + 链接方式
    - 进程的队列
      + 就绪队列
      + 等待队列
      + 运行队列
    - 进程队列的组成 :: 实际是PCB的链接 分为单向和双向链表
      + 出队 :: 从队列退出
      + 入队 :: 排入指定队列
      + 插队 :: 插入到某个进程队列的指定位置
*** 进程控制
    - 基本概念 :: 对进程整个生命周期 各种状态转换进行的控制 由原语控制
    - 原语 :: 由若干指令组成的 用于完成一定功能的一个过程 在执行过程中不被允许被打断
      + 创建原语
        * 一个进程可以使用创建原语创建新进程 前者为父进程 后者为子进程 子进程可以创建新的进程 从而形成进程家族
        * 主要任务 : 建立进程控制块PCB
        * 过程 :: 先申请空闲PCB 填入有关信息 设置进程状态为就绪 插入就绪队列
      + 撤销原语
        * 进程完成任务后 应当撤销它 以便及时释放它所占用的资源
        * 实质 :: 撤销进程控制块PCB
        * 过程 :: 找到要撤销的pCB 在队列中消去 撤销进程的子进程 释放所占资源 并消去PCB 
      + 阻塞原语
        * 进程执行需要I/O操作 将运行状态转换为阻塞状态
        * 过程 :: 产生中断 保存现场信息 进程设置为等待态 插入等待队列
      + 唤醒原语
        * 进程因等待事件而处于等待状态 该事件发生 就用唤醒原语转换为就绪状态
        * 过程 :: 找到进程 将状态置为就绪状态 将它从等待队列撤出并插入就绪队列排队 等待调度执行
** 线程
*** 线程的基本概念
    - 进程的属性
      + 一个可拥有资源的独立单位
      + 可独立调度和分派的基本单位
    - 程序并发执行所需付出的时空开销
      + 创建进程的开销
        * 内存空间 IO设备 
      + 撤销进程的开销
        * 对其资源作回收
      + 保留切换的开销
        * 保留CPU环境 设置新进程CPu环境
      + 这些开销限制了系统中进程数目 切换也不宜频繁 限制了并发程序的进一步提高
    - 引入线程的目的
      + 为了使多个程序并发执行
      + 为了减少并发执行所付出的开销
    - 什么是线程
      + 线程是进程的一个实体 是处理器调度和分配的基本单位
      + 线程基本上不拥有系统资源 只有少量运行必不可少的资源 但它可与同一个进程的其他线程共享所有资源
      + 一个线程可以创建和撤销另一个线程 同一个线程的多个线程可以并发执行
    - 线程的属性
      + 每个线程有一个唯一的标识和一张线程描述表
      + 不同线程可执行相同程序
      + 同线程可共享该进程的内存地址空间
      + 线程是处理器的独立调度单位 多个线程可以并发执行
      + 具有生命周期 经历等待 就绪 运行等状态变化
    - 引入线程的好处
      + 创建一个新线程的花费时间少
      + 线程之间切换花费时间少
      + 线程之间通信无需调用内核 不需要额外的通信机制 且简单 传送速度快
*** 进程和线程的比较
    - 调度
      + 同进程线程切换不引起进程切换 不同才因引起
    - 并发性
      + 多个线程可以并发 不同进程多个线程也可以并发
    - 拥有资源
      + 线程拥有隶属进程的资源 进程是拥有资源的独立单位
    - 系统开销
      + 线程低 进程高
*** 线程实现机制
    - 用户级线程
      + 仅存在用户空间 由用户层中的线程库提供线程的创建，撤销等支持
    - 内核级线程
      + 由OS直接支持 更l灵活 方便      
    - 混合方式
** 进程调度
*** 概述
    - 进程调度的主要功能
      + 记录系统 所有进程 执行状态
      + 根据一定调度算法 从就绪队列选出一个进程 把处理器分配给它
      + 分配处理器
    - 进程调度的时机
      + 正在执行的进程执行完毕
      + 正在执行的程序由于错误而终止运行
      + 时间片用完
      + 正在执行的进程调用阻塞原语将自己阻塞起来
      + 创建了新的进程
      + 正在执行的进程调用了唤醒原语操作激活了等待资源的进程
    - 处理器的调度方式
      + 非抢占方式
        * 进程一旦被执行 除非发生某事件而被阻塞 否则会一直运行到完成
      + 抢占方式
        * 允许根据某种原则 去暂停正在执行的进程 将处理器重新分配给另一进程
        * 能满足实时任务的需求 但比较复杂 开销较大
*** 调度算法设计原则
    - 进程行为
      + IO密集型和计算密集型
    - 系统分类
      + 批处理 交互式 实时系统
    - 调度算法设计目标
      + 共同目标 :: 资源利用率高 公平 平衡 强制执行策略
      + 批处理目标 :: 平均周转时间短 系统吞吐量高 处理机利用率好
      + 分时系统目标 :: 响应时间快 均衡性
      + 实时系统目标 :: 截止时间的保证 可预测性
*** 进程调度算法
    - 先来先服务
      + 算法思想 :: 最先进入就绪队列的进程 先执行 直到完成或者阻塞才释放处理器
      + 优点 :: 实现简单
      + 缺点 :: 没有考虑进程的优先级
    - 最短进程优先算法
      + 算法思想 :: 选出执行时间最短的进程先执行
      + 优点 :: 所有进程都同时运行时算法最优 
    - 最短剩余时间优先算法(抢占方式)    
      + 算法思想 :: 选择剩余时间最短的那个进程运行 有新进程到达时 对它们的剩余时间做比较 谁少执行谁
    - 最高响应比优先算法
      + 算法思想 :: 优先调度响应比最大的进程
      + 性能 :: 先来先服务和最短进程优先算法的折中
    - 轮转算法
      + 算法思想 :: 将处理时间划分成时间片
      + 影响时间片设置的因素
      + 系统响应时间
        * 就绪进程数目
        * 计算机的处理能力
    - 多级反馈

** 系统内核      
*** 内核的概念
    - 内核 :: 为了提高系统运行效率 将操作系统各种基本操作和基础功能 集中安排 形成一个系统的核心
*** 内核的位置
    - 一般常驻内存
*** 内核的功能
    - 中断处理程序
    - 进程同步与互斥
    - 进程调度
    - 进程控制与通信
    - 存储管理
    - 时钟管理
** 重点
*** 程序的顺序执行及其特点
*** 程序的并发执行及其特点
*** 进程的定义 特征
*** 进程的状态转换 重点三状态转换模型
*** 进程控制块
*** 进程控制原语
*** 线程的基本概念
*** 进程调度的功能 进程调度算法
*** 内核的概念 内核的功能
* 第四章 进程同步与互斥
** 进程间相互作用
*** 相关进程和无关进程
    - 相关进程 :: 逻辑上有某种关联
    - 无关进程 :: 逻辑上没有联系
*** 与时间有关的错误
    - 对于相关进程来说 可能有若干进程同时使用资源 形成交替使用共享资源
** 进程的同步与互斥
*** 进程的同步
    - 概念 :: 进程之间一种直接的协同工作关系 相互合作共同完成一项任务
      + 形成一种直接制约关系
*** 进程的互斥
    - 概念 :: 一些共享资源需要排他性的使用 个进程只能互斥使用这些资源 这种关系就是互斥
      + 间接制约关系
*** 临界区
    - 临界资源 :: 系统中某些资源只允许一个进程使用
    - 临界区 :: 访问临界资源的那段代码
    - 相关临界区 :: 若干进程共享某一临界资源
*** 相关临界区的调度使用原则
    - 当临界资源空闲 进程可以立即进入 --有空让进 有效利用资源
    - 临界资源占用时 其他进程需等待 --无空等待 互斥进入
    - 临界资源空闲 多个进程同时进入 选择一个 其他等待 --多种择一
    - 有效时间满足进程进入临界区的要求 -- 有限等待 避免死等
    - 处于等待的进程应放弃占用处理器 --让权等待 避免忙等
** 信号量及PV操作
*** 信号量
    - 提出
        1965 荷兰 Dijkstra 提出 他把信号量定义为用于表示资源树木的整形变量S 除初始化外 仅能通过P操作和V操作访问
    - PV操作的使用
      + P操作定义 :: P(S) S=S-1
        * 若S<0 将进程状态置为等待状态 将该进程PCB插入S信号量等待队列 直到其他进程在S执行V操作
      + V操作定义 :: V(S) S=S+1
        * 若S<=0 将进程状态置为就绪状态 将该进程PCB插入S信号量就绪队列 执行本操作的进程继续执行
      + 信号量S表示可用的资源
        * S>0 :: 表示某类资源的可用数量
        * S<0 :: 其绝对值表示排在S等待队列进程的数目
      + 执行一次P操作 表示请求一个资源
      + 执行一次V操作 表示进程释放一个资源
*** 用P V操作实现进程之间的互斥
    - 搞清楚 P V的操作 看例子就行了
*** 用P V操作实现进程见同步
    - 搞清楚 P V的操作 看例子就行了
*** 信号量及P V操作总结
    - P V操作必须成对出现
    - 互斥操作时 P V操作出现在同一进程
    - 同步操作时 P V操作出现在不同进程
    - 既有同步 又有互斥操作时 同步信号量P操作在前 互斥信号量P操作在后 V操作顺序不限
** 经典的进程同步问题
*** 简单生产者 消费者问题
    - 二者关系描述
      + 生产者放入产品到缓冲区 消费者从缓冲区取产品 进行消费
      + P进程不能往已经满的缓冲区放产品 Q进程不能从空的缓冲区取产品
    - 信号量设置
      + empty 初值为1 用于指示缓冲区数量
      + full 初值为0 用于指示缓冲区数量
*** 多个生产者 消费者问题
    - 同步问题和信号量设置
      + 生产者不能往满的缓冲区放产品 设置信号量empty初始值为k 只是缓冲池空缓冲区数目
      + 消费者不能从空缓冲区取 设置信号full 初值0 只是缓冲区的满缓冲区数目
*** 读者 写者问题
    - 假定有某个共享文件F 系统允许若干进程对文件进行读或者写 读文件为读者 写文件为写者
      + 多个进程可以同时读写文件F
      + 当一个进程写文件 不允许其他进程读写
      + 当一个进程读文件 不允许其他进程写
    - 问题分析
      + 写者进程与写者进程之间互斥文件F
      + 写者进程与第一个读者之间互斥访问文件
    - 变量设定
      + read_count :: 当前读者数量 来一个加一 走一个减一
      + mutex :: 互斥信号量 对read_count互斥访问
      + write :: 互斥信号量 写者与写者的互斥 写者与读者的互斥
*** 同步与互斥的综合应用
** 管程
*** 管程的提出
    - 信号量及PV操作的缺点
      + 程序易读性差
      + 程序不利于修改和维护
      + 正确性难以保证
*** 管程的概念及组成
    - 定义
      + 由过程 变量 数据结构组成的一个集合 他们组成一个特殊的模块或软件包 可在需要的时候调用
      + 管程名称 共享数据说明 对数据进行操作的一组过程 对共享数据赋初值的语句
** 进程通信
*** 共享内存
    - 原理
      + 相互通信的进程设一个公共区域 一组进程向该内存写 另一组读
*** 消息机制
    - 消息缓冲通信原理
      + 进程之间的数据交换 是以格式化的消息为单位的 利用操作系统提供的通信命令 实现大量数据的传输 过程透明
    - 消息机制--信箱
      + 为了实现进程间的通信 可以设计一个通信机构--信箱 以发送信件和接收信件为进程通信的基本方式
*** 管道通信
    - 管道 :: 用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件 又名pipe文件
    - 最早出现在UNIX系统 UNIX进程通信的一大特色
** 重点
*** 进程的同步和互斥的概念
*** 临界区 临界资源 进入临界区的原则
*** 信号量 PV操作的定义 物理含义 相关注意事项
*** 进程同步典型算法 生产者--消费者问题 读者--写者问题
*** 进程通信 ： 共享内存 消息通信 管道通信机制
* 第五章 死锁
** 死锁的产生
*** 死锁的定义
    - 在多道程序系统中 一组进程中的每一个进程无限的等待该组进程的另一个进程所占用且永远不会释放的资源
      + 处于死锁状态的进程为死锁进程
*** 产生死锁的原因
    - 资源的概念
      + 永久性资源(可重用资源) :: 如内存 外部设备 处理器等硬件资源 各种数据文件 表格 共享程序代码软件资源
      + 临时性文件(消耗性资源) :: 某个进程只为另一个进程使用一次 经过短暂时间便不再使用的资源 如 IO 时钟中断信号 同步信号
    - 产生死锁的原因
      + 竞争资源
        * 系统在资源分配出现失误 进程对资源的相互争夺造成僵局
      + 进程推进顺序不合理
    - 产生死锁的四个条件
      + 互斥条件
      + 不可剥夺条件
      + 请求和保持条件
      + 循环等待条件
    - 解决死锁的方法
      + 预防死锁
      + 避免死锁
      + 检测与解除死锁
      + 忽略死锁
** 死锁预防
*** 死锁预防的概念
    - 死锁预防
      + 在系统分配前 事先评估系统的可能情况 严格采取措施 使得死锁产生的四个条件不成立
      + 基本思想 :: 患于未然
      + 具体做法 :: 破坏产生死锁的四个必要条件之一
    - 静态的资源分配策略
      + 分配原则 :: 一个进程申请新资源的请求得不到满足 处于等待 将其全部资源剥夺
      + 破坏不可剥夺条件
        * 若一个进程已占用某些资源 又要申请新的资源 得不到新资源的同时释放原有资源 然后等待
        * 若一个进程申请新资源 如果资源可用则分配 否则从其他等待进程剥夺资源分配给该进程 如果没有该资源 进程必须等待 等待过程也有可能被剥夺资源 
      + 破坏请求和保持条件 
        * 进程在开始执行前就申请它所有需要的全部资源 仅当系统能满足进程的资源请求且吧资源一次性分配出去 该进程才能开始执行
    - 资源的有序分配法
      + 破坏循环等待条件
        * 对系统资源类型进行线性排序 赋予序号 进程申请资源 按照资源编号的顺序执行 一般较为紧缺 稀少的资源编号较大
*** 
** 死锁避免
*** 死锁避免的概念
    - 基本思想
      + 系统对进程发出的每一个能够满足的资源申请进行动态检查 根据检查结果决定是否分配 如果分配 不会发生死锁 则分配 否则不分配
    - 和死锁预防的区别
      + 死锁预防是破坏死锁条件 严格防止死锁出现 死锁避免是在系统运行过程注意避免死锁的发生 即使必要条件在 也不一定发生死锁
*** 安全状态与安全序列
    - 安全状态
      + 如果操作系统能够保证所有的进程在有限时间得到所需全部资源 则处于安全状态 否则不安全
      + 判别 :: 如果存在一个由系统中所有进程构成的安全序列{(P1,P2,...,PN)}则称系统处于安全状态
    - 安全序列
      + 系统能按某种进程推进顺序{(P1,P2,...,PN)}为每个进程分配其所需资源 直至满总是进程对资源的最大需求 是每个进程都可顺利完成 {(P1,P2,...,PN)}为安全序列
    - 银行家算法
      + Dijkstra 发明
      + 愿意
        * 确保银行在发放现金贷款时 不发发生不能满足所有客户需要的情况
      + 操作系统中
        * 保证系统不会进入不安全状态的算法
        * 判别 :: 如果存在一个由系统中所有进程构成的安全序列{(P1,P2,...,PN)}则称系统处于安全状态
    - 安全序列
      + 系统能按某种进程推进顺序为每个进程分配其所需资源 直至满总是进程对资源的最大需求 是每个进程都可顺利完成
** 死锁的检测与解除
*** 死锁的检测与解除
    - 死锁的检测与解除 
      + 在操作系统运行过程中 不断监督程序的执行和资源占用的情况 判断是否发生死锁 一旦发生死锁 采取专门的措施接触死锁 并以最小代价是系统回复正常
    - 死锁检测的时机
      + 检测的实质
        * 检测算法检测是否存在 循环等待条件
      + 时机 
        * 一次资源分配后
        * 每次调度后
        * 定时器定时运行检测程序
        * 当某个进程长期处于阻塞状态或阻塞程序过多时
*** 死锁检测的算法
    - 算法规则
      + 任意进程P申请一个已被占用的资源R时 进行死锁检测 反复查找资源分配表和等待进程表 来确定P对R的请求是否形成环路 若是 出现死锁
*** 解除死锁的方法
    - 剥夺资源
      + 一旦死锁 挂起一些进程 剥夺他们占用的资源给死锁进程 解除死锁
    - 撤销进程
      + 撤销部分死锁进程 将他们占有的资源分配给其他死锁进程直到解除死锁
      + 可以一次撤销所有死锁进程 也可以逐个撤销
** 资源分配图
*** 资源分配图
    - 作用
      + 描述系统资源分配和申请情况 对死锁进行分析并采取对策
    - SRAG定义
      +是一张有向图 定义为二元组 即SRAG = (V,E) 其中V是顶点的集合 包括 资源集合 进程集合 E是有向边的集合 是一个有序对<Pi,ri>
*** 死锁定理
    - 作用
      +判断死锁的法则
    - 死锁定理
      + 如果资源分配图没有环路 系统无死锁
      + 如果资源分配图出现了环路 可能存在死锁
*** 资源分配图简化方法
    - 资源分配图中 找出既不阻塞又非独立的进程节点 去除他的边 使之成为孤立的节点
    - 将P释放的资源分配给申请他的节点 若该进程能顺利运行完 释放资源 再次成为孤立节点
    - 重复前面两步 直到到不到符合条件后的进程结点
    - 经过简化后 若能消去所有的边 该图完全简化 系统不存在死锁 反之存在死锁
** 哲学家就餐问题
*** 问题描述
    - 有五个哲学家坐在圆桌 每人面前一只碗 碗里有面条 每两人之间一只筷子
    - 每个哲学家的行为是思考 感到饥饿 然后吃饭
    - 为了吃饭 每个哲学家必须拿到两只筷子 每个人只能从自己左边或者右边取筷子
*** 算法描述
    - 为每个筷子设置一个互斥型信号量
*** 存在问题
    - 死锁
*** 改进
    - 采用资源有序分配算法
        
** 重点
*** 死锁的定义 产生死锁的原因和必要条件
*** 死锁预防的概念 资源的静态分配策略 资源的有序分配法
*** 避免死锁的概念 安全状态与安全序列 银行家算法
*** 死锁检测的时机 死锁检测的算法 死锁解除方法
*** 资源分配图和死锁定理
*** 哲学家就餐问题
* 第六章 存储管理
** 存储管理的概述
*** 存储体系
*** 存储管理的任务
    - 内存空间分为两个区域
      + 系统区 :: 存放操作系统常驻内存部分 用户不能占用这部分空间
      + 用户区 :: 分配给用户使用 用于装入和存储用户的程序和数据 随时变化
    - 存储管理的实质
      + 用户空间的管理
    - 内存管理问题主要包括
      + 内存管理方法
      + 内存的分配与释放算法
      + 虚拟存储器的管理
      + 控制内存和外存之间的数据流动方法
      + 地址变换技术
      + 内存数据保护和共享技术
*** 内存的分配与回收
    - 功能
      + 记住每个存储区域的状态 :: 空闲与否
      + 实施分配 :: 用户提出请求 分配内存
      + 回收 :: 回收用户释放的区域
    - 内存分配表
      + 位示图表示法
      + 空闲页面法
      + 空闲块表法
    - 内存分配方式
      + 静态分配 :: 程序运行前分配内存 不允许 搬家
      + 动态分配 :: 程序运行允许动态分配内存 且允许搬家
*** 存储共享
    - 指两个或多个进程共用内存中相同区域
    - 包括 :: 代码共享 数据共享
    - 目的 :: 节省内存空间 提高内存利用率 通过共享实现进程通信
*** 存储保护
    - 目的 :: 为多个程序共享内存提供保障 内存的各道程序 只能访问自己的区域 避免各道程序相互干扰
    - 方法
      + 地址越界保护
      + 权限保护
*** 扩充内存容量
    - 用户编制程序时 不应该受内存容量的限制 要采用一定技术来扩充容量 使得用户得到比实际内存容量大的多的内存空间
    - 借助虚拟存储技术或交换技术完成 达到逻辑上扩充内存容量的目的
*** 地址转换
*** 地址重定位
    - 当用户把程序装入内存 逻辑地址与物理地址经常不一致
      + 绝对地址 :: 物理地址
      + 相对地址 :: 用户编程所用的地址
    - 逻辑地址转换为绝对地址就是 地址重定位 分为 静态和动态重定位
    - 静态重定位
      + 内存在装入一个程序时 把程序中的指令和数据地址全部转换为绝对地址 运行前进行 程序运行过程中不用在转换
    - 动态重定位
      + 内存装入一个程序时 不进行地址转换  而是直接把程序装入内存 在执行过程完成地址的转换

** 分区管理方案
*** 固定分区
    - 整个用户分区划分若干固定的大小区域 每个分区装入一个作业 分区大小可相同或不相同
    - 内存分配表 分区的分配 回收 
      + 内存分配表是一张分区说明表 记录分区号 分区大小 分区起始地址 使用状态
      + 分配时按照进程的内存需求 按一定的策略从分区表找到空闲分区进行分配
      + 回收时 将内存分区登记在分区说明表中 将其状态设置为空闲状态
*** 可变分区        
    - 基本思想
      + 装入程序时划分内存分区 是程序分配的内存大小等于程序的需求量 分区的个数可变
    - 紧缩技术
      + 内存经过一段时间 会存在很多很小的空间
      + 解决方法 :: 紧缩技术
      + 注意的问题
        * 增加系统的开销
        * 移动是有条件的 进程与设备交换信息 不能移动
      + 采用紧缩技术 应尽可能减少需要移动的进程数和信息量
    - 可变分区的实现
      + 硬件支持
        * 两个专用的控制寄存器 :: 基址寄存器和限长寄存器
      + 绝对地址形成
        * 程序装入内存后 分区的初始地址和长度装入两个寄存器 执行后 取出指令的逻辑地址
        * 绝对地址 = 逻辑地址 + 基址寄存器内容
      + 地址越界
        * 当逻辑地址 > 限长寄存器值时 产生地址越界中断
      + 地址转换过程
      + 内存分配表
        * 已分配区表
        * 空闲区表       
    - 可变分区的分配策略
      + 首次适应算法
        * 思想 :: 接到内存申请时 查找分区说明表 直到找到一个满足要求的空闲分区 将其分割并分配
        * 优点 :: 简单 快速做出分配决定
      + 最优适应算法
        * 思想 :: 接到内存申请时 查找分区说明表 找到一个满足要求的最小空闲分区 将其分割并分配
        * 优点 :: 节约空间
        * 简单  :: 形成许多碎片
      + 最坏适应算法
        * 思想 :: 接到内存申请时 查找分区说明表 找到一个满足要求的最大空闲分区 将其分割并分配
        * 优点 :: 碎片小
        * 简单  :: 遇到大的申请 无法满足
    - 分区的回收
      + 回收区与插入点的上邻空闲分区相邻接
        * 修改基地址为上邻空闲分区基地址 大小为两分区之和
      + 回收区与插入点的下邻空闲分区相邻接
        * 修改基地址为回收区基地址 大小为两分区之和
      + 回收区与插入点的上下邻空闲分区相邻接
        * 修改基地址为上邻空闲分区基地址 大小为三分区之和
      + 回收区没有相邻的空闲分区
    - 分区的保护
      + 两种方法
        * 系统设置界限寄存器 包括上下界寄存器或基址 限长寄存器
        * 保护键方法
*** 分区管理方案的优缺点    
    - 优点 
      + 简单 表格不多 实现容易 内存额外开销小 保护措施简单
      + 在内存利用率方面可变分区比固定分区高
    - 缺点
      + 碎片多 不能为用户提供 虚存 每个用户程序的存储受物理存储的限制

** 覆盖与交换技术 
*** 覆盖技术
    - 概念
      + 指一个程序的若干程序段 或几个程序的某些部分共享某一个存储空间
    - 实现
      + 把程序划分若干个相对独立的程序段 按照其自身逻辑结构是那些不会同时执行的程序短共享同一块内存区域
    - 解决的问题
      + 从用户级彻底解决内存小装不下程序的问题
    - 优点
      + 打破了需要将一个程序的全部信息装入内存后程序才能运行的限制
      + 逻辑上扩充了内存空间 在某种程度实现了在小容量内存运行较大程序的功能
    - 缺点
      + 对用户不透明 增加用户的负担 
*** 交换技术
    - 交换的含义
      + 进程从内存移到磁盘 并再移回内存
    - 使用场合
      + 分时系统和大多数现在操作系统 是虚拟存储系统的基础
    - 主要内容
      + 换出进程的选择
      + 交换时机的确定
      + 交换空间的分配
      + 换入进程换回内存时位置的确定
** 虚拟页式存储管理方案
*** 虚拟存储基础
    - 基本思想
      + 利用大容量外存扩充内存 产生一个比有限的实际内存空间大的多 逻辑的虚拟存储内存空间 简称虚存
      + 采用二级存储器方式
      + 是一种设计技巧 受外存容量的限制
    - 虚拟存储器需要硬件支持
      + 系统有容量足够大的外存
      + 系统有一定容量的内存
      + 实现虚-实转换的地址映射机制
    - 工作原理
      + 程序部分装入内存便可运行 其他部分需要运行式再装入内存
    - 与交换技术的区别
      + 交换技术交换单位是进程
      + 虚拟内存以页为单位进行交换
*** 虚拟页式存储管理
    - 物理页面和页面
      * 物理页面 :: 将内存分成大小相等的许多区 每个区称为一个物理页面
      * 页面 :: 将程序中的逻辑地址也进行分页 也的大小和物理页面大小一致
    - 虚拟地址组成
      + 虚拟页号
      + 页内地址
*** 物理内存的分配与回收
    - 位示图
      + 位示图中的每一位与一个物理块对应 其值为0/1 表示空闲/占用
    - 内存分配与回收
      + 分配 :: 在位示图中找出空闲物理页面数 如果能满足 则分配 并把相应位置为1 计算物理页面号
        * 物理页面号 = 字号 * 字长 +位号
      + 回收 :: 当归还物理页面时 计算归还页面在位示图中对应的位置 将1改为0
        * 字号 = [i/字长],位号 = i mod 字长
*** 虚拟页式存储地址转换过程
    - 页式存储管理的地址转换
      + 页表 :: 记录装入内存的逻辑页面与物理页面的对应关系
      + 是硬件进行地址转换的依据
      + 硬件支持 :: 页表始址寄存器和页表长度寄存器 分别用来存储正在运行过程的页表在内存的起始地址和页表的长度
      + 地址转换过程
        * 在执行检索前，先将页号与页表长度进行比较 若页号大于或等于页表长度 则地址越界
        * 若未出现越界错误 则将页表始址与页号和页表项长度的乘积相加 则找到该项在页表中的位置 找到该页的物理页号
        * 将有效地址的业内地址送入物理地址寄存器的块内地址字段中
      + 十进制转换 :: 物理页面号 * 块长 + 业内地址
      + 二进制转换 :: 物理页面号作为绝对地址的高位地址 业内地址作为它的地址部分
    - 页表项
      * 物理页面号 :: 页面在内存对应的物理页面号
      * 有效位 :: 页面是在内存中还是外存
      * 访问位 :: 页面在内存中是否被访问过
      * 修改位 :: 页面在内存中是否被修改过
      * 保护位 :: 页面能否读/写
    - 页表
      + 多级页表
      + 散列页表
      + 反置业表
    - 转换检测缓冲区(TLB)
      + 高速缓存 也成为快表 登记了页表内的部分页号和物理页面的对应关系
    - 缺页异常处理
      + 缺页异常 :: 若在页表中发现所要访问的页面不在内存 则产生缺页异常
      + 处理 :: 查看有无空闲页面 若有 把要访问的页面调入内存 若无 选择一页换出内存 再把要访问的页面调入内存
    - 页面调度策略
      + 调入策略 :: 决定什么时候将一个页面由外存调入内存 两种方法 请求调页和预调页
      + 置页策略 :: 当产生缺页 将所调入的页面置于何处
      + 置换策略 :: 如果内存已满 确定那个页面从内存中移出 为新的页面腾出空位 三种方法 固定分配局部置换 可变分配全局置换 可变分配局部置换
    - 页面置换算法
      + "抖动" 或 “颠婆” :: 刚被换出的页面又立即要用 把他装入内存后 不久又被换出 换出不久又被调入内存 如此反复 使调度非常频繁
      + 算法 :: OPT FIFO 第二次机会页面置换算法 CLOCK LRU算法
    - OPT--理想页面置换算法
      + 由Belady 1966 提出的一种理论的算法 其所选择的淘汰页面 将是以后不使用的 或者很久时间内不被再访问的页面 可保证获得最低的缺页率
    - FIFO--先进先出
      + 总是选择最先装入内存的页面调出
    - LRU--最近最少使用
      + 总是选择距离现在最长时间内没有被访问过的页面先调出
    - Belady现象 :: 当分配给进程的页面数增加时而缺页次数反而增加的现象
    - 缺页率
      + 缺页率计算 :: f = F | A
      + F为缺页次数 A为页面总访问次数
    - 影响缺页率的因素
      + 分配给程序的物理页面数
      + 页面的大小
      + 程序编制方法
      + 页面调度算法
*** 虚拟页式存储管理的优点缺点        
    - 优点
      + 不要求进程的的程序段和数据段在内存中连续存放 有效解决了碎片问题 提高了内存利用率
    - 缺点
      + 存在页面空间的浪费 程序的最后一页往往有一部分得不到利用  
*** 虚拟存储管理的性能问题
    - 颠簸问题
      + 缺页率高引起 如页面置换算法不合理
      + “活动页面” :: 进程在一段时间内集中访问的一些页面 与程序的局部性有关
      + 如果分配给进程的物理页面少 则活动页面不能全部装入内存 可能频繁产生缺页 从而导致颠簸
    - 工作集模型
      + 工作集 :: 对于给定的进程访问序列 从时刻(t-*)到时刻t之间所访问页面的集合 称为该进程的子集 *称之为工作集窗口
      + 采用工作集模型可以解决颠簸问题
      + 解决方法 :: 操作系统为每一个进程保持一个工作集 并为该进程提供与工作集大小相等的物理页面数 这一过程可动态调整
** 重点
*** 重要概念
    - 绝对地址 逻辑地址 地址重定位 动态重定位 静态重定位
*** 存储管理的任务
    - 内存的分配与回收 存储共享 存储保护 “扩充”内存容量
*** 分区管理方案
    - 为程序提供的是一个连续分区 程序运行前 必须全部装入内存
    - 固定分区基本思想 内存分配与回收
    - 可变分区的基本思想 紧缩技术 实现 空闲分区分配策略 分区的回收 分区的保护
    - 分区管理方案的优缺点
*** 覆盖与交换技术
*** 虚拟页式存储管理
    - 基本思想 硬件支持 地址结构 分配与回收 地址转换 缺页处理 页面置换算法
* 第七章 文件管理
** 文件系统的基本法概念  
*** 文件系统的任务
    - 文件的定义
      + 研究文件系统的两种观点
        * 用户观点 :: 关心文件由什么组成 如何命名 如何保护文件 可以进行和中操作
        * 系统观点 :: 文件目录是怎么样实现的 怎样管理存储空间 文件存储位置 磁盘实际运作方式 存取速度 磁盘利用率
      + 文件的定义 :: 一组带标识的 在逻辑上有完整意义的信息项的序列
      + 读写指针 :: 读指针用来记录文件当前的读取位置 写指针用来记录文件当前的写入位置
      + 特点 :: 存储在磁盘上 可长期保存
    - 文件系统的定义
      + 操作系统中统一管理信息资源的一种软件 它管理文件的存储 检索 更新 提供更安全的共享和保护手段 并且方便用户使用
      + 功能
        * 统一管理文件的存储空间 实施存储空间的分配与回收
        * 实现文件按名存取 以对用户透明的方式管理名字空间
        * 实现文件信息的共享 并提供文件的共享和保密措施
        * 向用户提供一个方便使用的接口
        * 系统维护及向用户提供有关信息
        * 保持文件系统的执行效率
        * 提供与IO的统一接口 
*** 文件的存储介质及存取方式
    - 外存储设备的特点
      + 特点 :: 容量大 断电后仍可保存信息
      + 组成 :: 驱动部分和存储介质部分
    - 种类 :: 磁盘 磁带 磁鼓 纸带 光盘 闪存
      + 磁带
        * 特点 :: 容量大 存取速度慢 适合顺序存储
      + 磁盘
        * 分类 :: 软盘和硬盘
        * 特点 :: 容量大 成本低 适合随机存储
        * 磁盘的物理地址由柱面号 磁头号 扇区号组成
      + 光盘
        * 是利用在激光的作用下特性发生变化的一些材料的非磁性记录介质
        * 特点 :: 容量大 速度快 价格便宜
      + 闪存
        * 特点 :: 电擦除 随即存取 可靠性高 寿命长
    - 文件在存储设备中的存取方式
      + 顺序存取 :: 按从前到后的次序一次访问文件的各个信息项
      + 随即存取 :: 又称直接存取 允许用户按任意的次序 直接存取文件中的任意一个记录 或者根据命令把读写指针移到文件中的指定记录处读取
*** 文件的分类
    - 按文件的用途分类
      + 系统文件
      + 库函数文件
      + 用户文件
    - 按文件的组织方式
      + 普通文件
      + 目录文件
      + 特殊文件
    - 一些常见的文件分类方式
      + 按文件的保护方式 :: 只读文件 读写文件 可执行文件 无保护文件
      + 按信息的流向分 :: 输入文件 输出文件 输入输出文件
      + 按存放时限分 :: 临时文件 永久文件 档案文件
      + 按存储介质分 :: 磁盘文件 磁带文件 卡片文件
      + 按文件的组织结构分类 :: 逻辑文件 物理文件
    - UNIX类操作系统中文件的分类
      + 普通文件
      + 目录文件
      + 特殊文件
** 文件的逻辑结构和物理结构
*** 文件的逻辑结构
    - 设计文件逻辑结构的原则
      + 易于操作
      + 查找快捷
      + 修改方便
      + 空间紧凑
    - 文件的逻辑结构 
      + 文件的逻辑结构所描述的信息是文件中信息的组织形式 可分三类
        * 流式文件 :: 有序字符的集合 基本单位是字符 源程序 目标代码等属于流式文件
        * 记录式文件 :: 是一组有序记录的集合 基本单位是记录 有可分为定长记录文件和变长记录文件
*** 文件的物理结构
    - 顺序结构
      + 原理
        * 又称连续结构 他把逻辑上连续的文件信息一次存放在连续编号的物理块中
      + 优缺点
        * 优点
          1. 存取速度块 一旦知道文件在存储设备上的起始块号和文件长度 便能快速地进行存取
          2. 支持顺序存放和随即存放
        * 缺点
          1. 文件不能动态增长
          2. 要求为一个文件分配连续的存储空间
          3. 不能灵活地删除和插入记录
          4. 出现碎片
    - 链接结构
      + 链接结构原理
        * 将逻辑上连续的文件分散存储在若干个不连续的物理块中 每个物理块中都没有一个指针 指其后续的物理块
      + 链接结构的优缺点
        * 优点
          1. 解决了碎片问题 提高了磁盘空间的利用率
          2. 文件可以动态扩充
        * 缺点
          1. 存取速度慢 不适于随即存取
          2. 可靠性差
    - 索引结构
      + 原理
        * 为每个文件分配一个索引表 把分配给该文件的所有盘块号 都记录在该索引表中
      + 优缺点
        * 优点
          1. 文件动态增长
          2. 不要为一个文件分配连续的存储空间
          3. 能灵活地删除和插入记录
          4. 能顺序存取和随即存取
        * 缺点
          1. 引起较多的寻道次数和寻道时间
          2. 索引表本身增加了存储空间的开销
      + 多级索引
        * 索引块太多时 单级索引效率低 可以在建立一级索引 便形成了两级索引分配方式 还可用三级 四级索引分配方式









 
