* 第一章
** 出现原因
  - 软件危机的出现 12306铁路
    + 开发速度慢
    + 质量低
    + 成本高
  - 软件工程 :: 计算机技术和工程原则 实现 开发快 质量高 成本低的项目
  - 发展
    + 开发模型 开发方法 支持工具
    + 软件复用技术 开发管理
** 开发本质
   - 软件概念 :: 程序 + 文档
   - 本质 :: 映射 不同层次的映射
   - 模型 :: 一个抽象
     + 概念模型 :: 描述软件是什么
     + 软件模型 :: 实现概念模型的软件解决方案
** [[file:r软件工程/res/软件工程第一章.png][小结]]
* 第二章
** 获取需求
   - 定义 :: 描述系统功能行为 性能参数或其他性质
   - 基本性质
     1. 必要的
     2. 无歧义的
     3. 可测的
     4. 可跟踪的
     5. 可测量的
   - 需求分类
     1. 功能需求 主体
     2. 非功能需求 性能 设计约束 质量 接口
   - 需求发现
     1. 自悟
     2. 交谈
     3. 观察
     4. 小组会
     5. 提炼
** 需求规约
   - 定义 :: 软件所有需求陈述的正式文档 表达软件的概念模型
   - 基本性质
     + 重要性 稳定性 需求分级
     + 可修改的
     + 完整的 :: 没有被遗漏
     + 一致的 :: 不存在互斥的需求
** 需求规约的格式
   - 引言
   - 总体描述
   - 特定需求
   - 附录
   - 索引
** 需求规约的表达
   1. 非形式化的需求规约
   2. 半形式化的需求规约
   3. 形式化的需求规约
** 需求规约的作用
   1. 需求规约是软件开发组织和用户之间一份事实之间的技术合同书 产品功能及环境的体现
   2. 是一个管理控制点
   3. 对于产品的设计 是一个正式的，受控的起始点
   4. 创建产品验收计划和用户指南的基础
** [[file:r软件工程/res/软件工程第二章.png][小结]]
* 第三章
** 需求分析
   - 挑战
     1. 问题空间理解
     2. 人与人之间的有效沟通
     3. 需求的变化性
   - 需求技术的基本特征
     1. 提供方便通信的机制
     2. 史通问题空间的术语思考 编写文档
     3. 提供定义系统边界的方法
     4. 提供支持抽象的基本机制
     5. 提供多种可供选择的方案
     6. 提供特定的技术 适应需求的变化
   - 基本术语
     + 数据 :: 客观事物的一种表示
     + 信息 :: 具有特定语义的数据
     + 数据是信息的载体
     + 数据流 :: 数据的流动
     + 加工 :: 数据变换单元
     + 数据存储
     + 数据源和数据目的地
   - 表示方法
     [[file:r软件工程/res/表示方法.png][表示方法图解]]
** 系统功能模型的表示方法
   - 数据流图 DFD
     + 一种表示数据变换的图形化工具
   - 数据流程图的元素
     + 数据源/数据潭 数据流 数据存储 加工 
** 建模过程 :: 自顶向下 功能分解
   - 建立系统环境图
   - 0层图
   - 1层图
** 数据字典
   - 定义 :: 定义数据流程图中所有数据流和数据存储的数据结构
   - 顺序结构 :: +
   - 选择结构 :: |
   - 重复结构 :: {}
   - 子界 :: m..n
** 加工的描述
   - 判定表
     + 也称为决策表 是一个二维表 说明每一种条件组合产生的结构
     + 有四个象限
       * 左上限 :: 所有的条件
       * 左下限 :: 可能的结果
       * 右上限 :: 每一种条件的取值(Y和N表示)
       * 右下限 :: 所对应的条件子和所产生的结果
   - 判定树
     + 决策表 用来描述在一组不同的条件下 决策的行动根据不同及取值来选择的处理过程
   - 结构化语言
** 应用中注意的问题
   - 模型平衡问题
     + DFD图与数据字典一致
     + 底层加工的处理逻辑描述 与数据字典一致
   - 信息的复杂性控制问题
     + 上层数据流可以打包
     + 下层模块个数 7 +- 2
     + 每个加工的数据流不能太多
** 结构化设计
   - 总体设计的步骤
     将DFD图映射为设计层面的模块及模块调用
     + 将DFD图转换为初始的模块结构图
     + 基于“高内聚，低耦合”的软件设计原理，同工程模块化 将初始的模块结构转化为最终的模块结构图
   - 两种映射方法
     + 变换设计
       基于变换的数据流程图是一个线性的顺序结构 由输入输出和变换中心三部分组成
     + 事务设计
       基于事务的数据流程图中有一个事务处理中心 它将输入分为许多相互平行的加工路径后根据输入的属性 选择某一加工路径
** 模块化及其启发式规则
   - 模块
     执行一个特殊任务的一个过程及其相关的数据结构 由模块接口和模块体组成
   - 模块化的两个问题
     1. 如何将系统分解成软件模块
        1. “分而治之” 和“抽象”
        2. 自顶向下 逐步求精
        3. 形成模块层次结构
     2. 如何设计模块
   - 模块化
     把一个待开发的软件分解成若干简单的、具有高内聚低耦合的模块的过程
     + 模块耦合
       两个模块相互依赖的一种度量 依赖越小越好
       * 内容耦合 :: 一个模块直接修改或操作另一模块数据
       * 公共耦合 :: 两个模块共同引用一个全局数据項
       * 控制耦合 :: 一个模块向另一个模块传递控制信号
       * 标记耦合 :: 一个模块向两个模块传递一个公共参数
       * 数据耦合 :: 模块之间通过参数来传递数据
     + 模块内聚
       模块内部相互关联程度的度量 越高越好
       * 偶然内聚 :: 模块的各成分没有任务关系
       * 逻辑内聚 :: 逻辑上相关的 处理放在一起
       * 时间内聚 :: 模块内的功能在同一时间完成
       * 过程内聚 :: 模块内的处理以特定的次序执行
       * 通信内聚 :: 操作同一数据集
       * 顺序内聚 :: 一个成分的输出作为另一成分的输入
       * 功能内聚 :: 模块的所有成分完成单一的功能
     + 启发式规则
       “高内聚，低耦合”
       * 改进软件结构 提高软件独立性 模块分解
       * 模块规模适中
       * 为求深度 宽度 扇出 扇入适中
         - 深度 :: 表示控制的层数
         - 宽度 :: 同一层次模块总数的最大值
         - 扇出 :: 一个模块直接控制的下级模块的数目
         - 扇入 :: 有多少个上级模块直接调用它
       * 尽量使模块的作用域在其控制域内
         - 模块的控制域 :: 这个模块本身以及所有直接或间接从属它的模块的集合
         - 模块的作用域 :: 受该模块内的一个判断所影响的所有模块的集合
       * 尽力降低模块接口的复杂度
       * 力求模块功能可以预测
** 详细设计
   给出详细模模块功能的实施机制 包括一组例程和数据结构
   - 结构化程序的设计方法
     基于结构的变成方法 采用顺序结构 选择结构 重复结构进行编程 每一结构只允许一个入口和出口
     + 本质 :: 控制流程线性化 实现程序动态执行顺序符合静态书写的结构 提高程序的可读性
   - 详细设计工具
     + 程序流程图 :: 描述过程设计的方法 最混乱的一种方法
     + N-S 盒图 :: 不允许违背结构程序设计精神的图形工具考虑，提出的
     + PAD图 :: 问题分析图 用二维树形结构的图来表示控制流 翻译成代码比较容易
     + 类程序设计语言PDL :: PDL称为伪码 正文形式表示数据和处理过程的设计工具
** 设计规约
   - 概要设计规约
     1. 系统环境
     2. 软件模块的结构
     3. 模块描述
     4. 文件结构和全局数据文件的逻辑文件
     5. 测试需求
   - 详细设计规约
     + 各处理过程的算法
     + 算法涉及的全部数据结构的描述
** [[file:r软件工程/res/软件系统第三章.png][小结]]
* 第四章
** UML术语表
*** 对象 
    系统用来描述客观事物的一个实体 由一组属性和一组方法组成
*** 类
    具有相同属性 操作 关系和语义的一组对象的集合 抽象描述
*** 属性
    描述对象的具体特征 有属性名和属性值
    具有可见性 属性名称 类型缺省值和约束特性
*** 类的操作
    通常被称为功能 被约束在类的内部 只能作用到该类的对象上
*** 接口
    是操作的一个集合 每个操作描述了类，构件或子系统的一个服务
    - 采用具有分栏和关键字的矩形符号来表示
    - 采用小圆圈和半圆圈来表示
*** 协作
    是一个交互 涉及几乎三要素 交互各方 几乎方式 交互内容
*** 用况
    对一组动作系列的描述 系统执行这些动作应产生特定参与者有值黛儿 可观察的结果
*** 主动类
    至少具有一个进程或线程的类 能够启动系统的控制活动 并且其对象的行为通常与其他元素行为并发的
    - 表示方法 :: 两条竖线
*** 构件
    系统设计中塞尔一种模块化部件 通过外部接口隐藏了它的内部实现
    - 具有相同的接口的构件可以相互替代
    - 可以嵌套
*** 制品
    - 系统中包含物理信息的 可替代的物理部件
*** 节点
    运行时存在的物理元素 表示一种具有记忆能力和处理能力的计算机资源
** 表达关系的术语
*** 关联
    反映了类和类之间的静态关系 最基本的关系
    链是对象之间具有特定语义关系的抽象
    - 关联名
    - 导航
    - 角色
    - 可见性
    - 多重性 :: 可能出现的最小和最大的数目
    - 限定符
    - 聚合 :: 一个类是另一类的一部分
    - 组合 :: 聚合的特殊形式
    - 关联类
      + 具有关联和类特性的模型元素
    - 约束
      + 有序 无序
*** 泛化/继承
    子类的对象可以拥有一般一般类的全部属性与服务
*** 细化
    细化是类目之间的语义关系 空心三角形表示
*** 依赖 
    用于描述一个类目使用另一类目的信息和服务 用有向虚线段表示。

* 第五章
** RUP的特点
   以用况驱动的 以体系结构为中心的迭代 增量式开发
   - 用况驱动
     + 用况是能够向用户提供有价值结果的系统中的一种功能
     + 用况获取的是功能需求
   - 以体系结构为中心
     + 系统语义的概括描述 对所有项目有关人员都是可以理解的
   - 迭代与增量
     + 迭代是重复的部分
     + 增量是增加的部分
   - 二维开发模型
     + 初始阶段
       * 为系统建立商业案例并确定项目的边界
     + 细化阶段
       * 分析问题领域 建立体系结构基础 编制项目计划 淘汰项目中最高风险的元素
     + 构造阶段
       * 所有剩余的构件和应用程序功能被开发集成为产品 所有的功能被详细测试
     + 交付阶段
       * 确保软件对最终用户是可用的
** 核心工作流
*** 需求获取
    RUP运用用况技术来获取需求
    - 列出候选的需求 :: 特征列表
    - 理解系统语境 :: 领域模型或业务模型
    - 捕获功能需求 :: 用况模型
    - 捕获非功能需求 :: 补充需求或针对一些特定的用况
*** 需求分析
    在系统用况模型基础上 创建分析模型以及在该分析模型视角下的体系结构描述
    - 分析类 :: 很少有操作和特征标记 属性和关系也是概念性的
      + 存在三种不同类型的类 :: 实体类 边界类 控制类
    - 用况细化
      + 是一个协作
      + 针对一个用况 其行为可以用多个分析类之间的相互作用细化
*** 软件设计
    RUP 的设计目标： 定义满足系统/产品分析模型所规约需求的软件结构
